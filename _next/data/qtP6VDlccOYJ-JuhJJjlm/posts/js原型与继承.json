{"pageProps":{"postData":{"id":"js原型与继承","content":"<p>明确概念 ： </p>\n<ol>\n<li>构造函数</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Foo</span>(<span class=\"hljs-params\">name</span>)</span>{\n    <span class=\"hljs-built_in\">this</span>.name = name\n  } </code></pre>\n<blockquote>\n<p>特征：函数名大写开头,用来生成新对象</p>\n</blockquote>\n<ol start=\"2\">\n<li>原型对象 Foo.prototype</li>\n</ol>\n<blockquote>\n<p>特征：显式原型,用了实现继承。打印: Foo.prototype === instance.<code>__proto__</code>   //true</p>\n</blockquote>\n<ol start=\"3\">\n<li>实例 var instance = new Foo('neo') </li>\n</ol>\n<blockquote>\n<p>特征：用构造函数生产出来的对象,打印: Foo {name:\"neo\"}</p>\n</blockquote>\n<ol start=\"4\">\n<li>每个实例对象（ object ）都有一个私有属性（称之为<code>__proto__</code> ）指向它的构造函数的原型对象（prototype ）</li>\n</ol>\n<h3>三个属性关系</h3>\n<p>一段说明代码</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Foo</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">this</span>.name = name\n}\n\n<span class=\"hljs-keyword\">var</span> instance = <span class=\"hljs-keyword\">new</span> Foo(<span class=\"hljs-string\">'neo'</span>)\n\n<span class=\"hljs-built_in\">console</span>.log(Foo.prototype)\n<span class=\"hljs-built_in\">console</span>.log(Foo.prototype.constructor)\n<span class=\"hljs-built_in\">console</span>.log(Foo.__proto__)\n<span class=\"hljs-built_in\">console</span>.log(Foo.prototype.__proto__)\n\n<span class=\"hljs-built_in\">console</span>.log(instance.constructor)\n<span class=\"hljs-built_in\">console</span>.log(instance.__proto__)\n\n<span class=\"hljs-comment\">// {constructor: ƒ}</span>\n<span class=\"hljs-comment\">// ƒ Foo() {this.name = name}</span>\n<span class=\"hljs-comment\">// ƒ () { [native code] }</span>\n<span class=\"hljs-comment\">// {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__:…}</span>\n\n<span class=\"hljs-comment\">// ƒ Foo() {this.name = name}</span>\n<span class=\"hljs-comment\">// {constructor: ƒ}</span></code></pre>\n<p>Foo (构造函数) , Foo.prototype (原型对象) ,  instance (实例) 三个东西</p>\n<p>Foo.prototype === instance.<em>proto</em></p>\n<p>instance.constructor === Foo === Foo.prototype.constructor </p>\n<p>Foo.prototype.<code>__proto__</code> === Object.prototype</p>\n<h3>属性讲解</h3>\n<ul>\n<li>\bprototype(指向原型对象)</li>\n</ul>\n<p>只有<code>函数</code>才会有这个属性,在上述代码可以看到,返回一个对象,对象里有一个<code>constructor</code>的方法。</p>\n<ul>\n<li>constructor(指向原型对象的构造函数)</li>\n</ul>\n<p>在<code>Foo.prototype.constructor</code>打印中发现,它指向函数本身,所以这两个属性其实是一个转换过程</p>\n<blockquote>\n<p>Foo => Foo.prototype => Foo.prototype.constructor => Foo</p>\n</blockquote>\n<ul>\n<li><code>__proto__ </code> (指向创建该对象的构造函数原型)</li>\n</ul>\n<p>每个对象都有<code>__proto__ </code> ,隐式的原型属性(prototype是显性的),原型链就是利用<em>proto</em>实现一层一层接驳,达到访问原型链上不属于自己的属性</p>\n<p>Foo.<code>__proto__ </code>指向的是Function.prototype,因为Foo的上一层是Function</p>\n<blockquote>\n<p>完整原型链: Foo => Foo.<code>__proto__ </code> => Function.prototype => Function.prototype.<code>__proto__ </code> => Object.prototype => Object.prototype.<code>__proto__ </code>=> null</p>\n</blockquote>\n<p>附上一张图</p>\n<p><img src=\"../images/PrototypeChain.png\" alt=\"prototypechain\"></p>\n","title":"原型与继承","date":"2020-08-06","kind":"Base"}},"__N_SSG":true}
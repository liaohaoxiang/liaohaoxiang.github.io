{"pageProps":{"postData":{"id":"await详解","content":"<blockquote>\n<p>async 不用多说，代表这个函数有异步操作,关键是 await 如何理解</p>\n</blockquote>\n<p>可以根据一个栗子引出思考</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async1</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"a\"</span>);\n  <span class=\"hljs-keyword\">await</span> async2();\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"b\"</span>);\n}\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">async2</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">'c'</span>);\n}\nasync1();\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">resolve</span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"d\"</span>);\n  resolve();\n}).then(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">\"e\"</span>);\n});</code></pre>\n<p>如果你是在 chrome 70 上做测试，那么返回的顺序将会是：</p>\n<pre><code class=\"hljs language-shell\">a\nc\nd\ne\nb</code></pre>\n<p>如果你在 chrome canary 73 或以上测试，那么返回的将会是：</p>\n<pre><code class=\"hljs language-shell\">a\nc\nd\nb\ne</code></pre>\n<p>两个测试结果的<code>async1 end</code> 会不一样，是因为 v8 引擎做了优化。</p>\n<h2>从 Promise 引出 Async 的修改原因</h2>\n<p>阅读了这遍文章后，对于 await 有进一步的看法<a href=\"https://github.com/xianshenglu/blog/issues/60\">promise, async, await, execution order</a></p>\n<p>开始前需要有一个认识，我们平时使用构造函数生成 Promise 实例，我们称为 RESOLVE(something)</p>\n<pre><code class=\"hljs language-js\">RESOLVE(p) === <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n    resolve(p);\n  });</code></pre>\n<p>而另外一种创建 Promise 实例方式，更简洁，就是 Promise.resolve()</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-string\">'foo'</span>) === <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> resolve(<span class=\"hljs-string\">'foo'</span>));</code></pre>\n<p>直接上结论：</p>\n<ul>\n<li>Promise.resolve(<code>nonThenable</code>)与 RESOLVE(<code>nonThenable</code>) 全等。</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">// 对于Promise参数为原始值，都等于这种情况。 ---摘要自《ES6标准入门》P289 by阮一峰</span>\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  resolve(nonThenable);\n});</code></pre>\n<ul>\n<li>Promise.resolve(<code>thenable</code>)和 RESOLVE(<code>thenable</code>)是不同的。它们有不同的效果。</li>\n</ul>\n<ul>\n<li>RESOLVE(thenable)和 RESOLVE(promise)都可以转化为</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> resolve(thenable)) === <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span>=></span> {\n  <span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\">() =></span> {\n    thenable.then(resolve);\n  });\n});</code></pre>\n<ul>\n<li>Promise.resolve(promise) === promise,即不作任何修改，原封不动返回这个 promise 实例。 而 Promise.resolve(nonPromiseThenable)可以转化为</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =></span> {\n  <span class=\"hljs-built_in\">Promise</span>.resolve().then(<span class=\"hljs-function\">() =></span> {\n    nonPromiseThenable.then(resolve);\n  });\n});</code></pre>\n<p>疑点: 在 RESOLVE(thenable)中是 === Promise.resolve(nonPromiseThenable)</p>\n<p>下面两个例子可以看出 两者在处理 Promise 为参数时所带来的的不同</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-comment\">//Promise.resolve(promise)</span>\n<span class=\"hljs-keyword\">let</span> p1 = <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-built_in\">Promise</span>.resolve(p1).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(res);\n});\np1.then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>);\n});\n<span class=\"hljs-comment\">//1</span>\n<span class=\"hljs-comment\">//2</span>\n\n<span class=\"hljs-comment\">//RESOLVE(promise)</span>\n<span class=\"hljs-keyword\">let</span> p1 = <span class=\"hljs-built_in\">Promise</span>.resolve(<span class=\"hljs-number\">1</span>);\n<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =></span> {\n  resolve(p1);\n}).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(res);\n});\np1.then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-number\">2</span>);\n});\n<span class=\"hljs-comment\">//2</span>\n<span class=\"hljs-comment\">//1</span></code></pre>\n<h2>回到await</h2>\n<p><a href=\"&#x27;https://github.com/tc39/ecma262/pull/1250&#x27;\">Normative: Reduce the number of ticks in async/await</a></p>\n<p>根据这个对于await的修改，揭露了await优先级提高的原因: 如果await后面的代码是promise，那么将使用Promise.resolve而不是使用RESOLVE()重新生成promise实例。</p>\n<p>上面提到，Promise.resolve(promise)会原封不动把promise返回，因此时序上比RESOLVE提升了</p>\n<p>所以await可以完全转换为promise.resolve()去理解</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> async1 = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> res1 = <span class=\"hljs-keyword\">await</span> p1\n  <span class=\"hljs-built_in\">console</span>.log(res1)\n}</code></pre>\n<p>转换成</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">const</span> async1 = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">Promise</span>.resolve(p1).then(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =></span> {\n    <span class=\"hljs-keyword\">const</span> res1 = res\n    <span class=\"hljs-built_in\">console</span>.log(res1)\n  })\n}</code></pre>\n<!-- ## Promise的语法糖\n其实这道题问的是\n\n> await P 怎么理解?\n\n又因为 ```async```函数总是返回一个promise,所以其实就是在问\n\n> await Promise 怎么理解?\n\n```js\nasync function async1(){\n  await P\n  console.log('async1 end')\n}\n```\n\n等价于\n\n```js\nasync function async1() {\n  return new Promise(resolve => {\n    resolve(P)\n  })\n  return new Promise.resolve(p).then(() => {\n    console.log('async1 end')\n  })\n}\n```\n\n```js\nawait === new Promise(resolve => {\n    resolve('跟在你await后面的函数')\n    }).then(()=>{'await下面的代码'})\n``` -->\n<!-- > 『RESOLVE(p)』接近于『Promise.resolve(p)』，不过有微妙而重要的区别：p 如果本身已经是 Promise 实例，Promise.resolve 会直接返回 p 而不是产生一个新 promise\n\n## await [promise]\n\n如果 P 是一个 promise 函数(如上述的 async2,因为 async 永远会返回一个 promise),那么在 await 规范更改后,await 就等价于\n\n```js\n(await async2()) ===\n  Promise.resolve(async2()).then(res => {\n    console.log('async1 end');\n  });\n```\n\n那么对于 `resolve(async2())`，我们可以根据规范转换成：\n\n```js\nPromise.resolve().then(() => {\n  async2().then(resolve);\n});\n```\n\n所以 async1 就变成了这样：\n\n```js\nasync function async1() {\n  return new Promise(resolve => {\n    Promise.resolve().then(() => {\n      async2().then(resolve);\n    });\n  }).then(() => {\n    console.log('async1 end');\n  });\n}\n``` -->\n","title":"async/await中 await怎么解释？","date":"2020-07-18","kind":"Base"}},"__N_SSG":true}